"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// package.json
var require_package = __commonJS({
  "package.json"(exports, module2) {
    module2.exports = {
      name: "@pixso/plugin-cli",
      version: "1.0.7",
      description: "plugin cli",
      bin: {
        "plugin-cli": "bin/plugin-cli.js"
      },
      main: "dist/index.js",
      types: "dist/index.d.ts",
      keywords: [
        "pixso",
        "pixso-plugin",
        "pixso-plugin-cli"
      ],
      private: false,
      publishConfig: {
        access: "public",
        registry: "https://registry.npmjs.org/"
      },
      engines: {
        node: ">=16.16.0"
      },
      scripts: {
        dev: "jiti index.ts",
        build: "tsup"
      },
      author: "Pixso",
      license: "MIT",
      devDependencies: {
        "@types/archiver": "^6.0.2",
        "@types/express": "^4.17.17",
        "@types/express-ws": "^3.0.1",
        "@types/ip": "^1.1.0",
        "@types/memory-fs": "^0.3.3",
        "@types/webpack-hot-middleware": "^2.25.6",
        "@types/ws": "^8.5.4",
        ip: "^1.1.8",
        "svelte-loader": "^3.1.8",
        tsup: "^6.7.0",
        typescript: "^4.9.3",
        vue: "^3.2.47",
        "vue-loader": "^17.0.1",
        "vue-style-loader": "^4.1.3"
      },
      dependencies: {
        "@swc/core": "^1.3.44",
        "@swc/helpers": "^0.5.0",
        archiver: "^6.0.1",
        c12: "^1.2.0",
        cac: "^6.7.14",
        chalk: "4.1.0",
        chokidar: "^3.5.3",
        "css-loader": "^6.7.3",
        esbuild: "^0.17.15",
        "esbuild-loader": "^3.0.1",
        express: "^4.18.2",
        "express-ws": "^5.0.2",
        hookable: "^5.5.3",
        "html-webpack-plugin": "^5.5.0",
        "http-proxy-middleware": "2.0.6",
        jiti: "^1.18.2",
        "local-pkg": "^0.5.0",
        "memory-fs": "^0.5.0",
        ora: "5.0.0",
        rimraf: "^4.4.1",
        "style-loader": "^3.3.2",
        "svg-url-loader": "^8.0.0",
        "swc-loader": "^0.2.3",
        "terser-webpack-plugin": "^5.3.7",
        "url-loader": "^4.1.1",
        webpack: "^5.77.0",
        "webpack-chain": "^6.5.1",
        "webpack-dev-middleware": "6.1.1",
        "webpack-hot-middleware": "2.25.3",
        "webpack-merge": "^5.9.0",
        webpackbar: "^5.0.2",
        ws: "^8.13.0"
      }
    };
  }
});

// lib/cli.ts
var import_cac = require("cac");

// lib/webpack/config.ts
var import_webpack_chain = __toESM(require("webpack-chain"));
var import_webpackbar = __toESM(require("webpackbar"));
var import_path = __toESM(require("path"));

// lib/config.ts
var import_c12 = require("c12");
var import_hookable = require("hookable");
var import_local_pkg = require("local-pkg");
var import_promises2 = __toESM(require("fs/promises"));
var import_node_path2 = __toESM(require("path"));

// lib/utils.ts
var import_chokidar = __toESM(require("chokidar"));
var import_chalk = __toESM(require("chalk"));
var import_promises = __toESM(require("fs/promises"));
var import_node_path = __toESM(require("path"));
var root = process.cwd();
var watchFile = (path5, callback) => {
  return import_chokidar.default.watch(path5).on("add", callback).on("change", callback).on("unlink", callback);
};
var log = {
  info: (text) => {
    console.log(import_chalk.default.green("[plugin-cli]: "), text);
  },
  err: (text) => {
    console.log(import_chalk.default.red("[plugin-cli]: "), text);
  }
};
var rootResolve = (p) => import_node_path.default.resolve(root, p);
var isExistsFolder = async (p) => {
  try {
    const res = await import_promises.default.stat(rootResolve(p));
    return res.isDirectory();
  } catch {
    return false;
  }
};

// lib/config.ts
var localConfig = {
  main: "./main.ts",
  mainBuild: true,
  manifest: "./manifest.json",
  frame: "vue",
  ui: "./ui/index.ts",
  template: "./ui/ui.html",
  host: "",
  hostBuild: true
};
var hasTs = () => localConfig.ui?.endsWith(".ts") || localConfig.ui?.endsWith(".tsx");
var analysisFrame = () => {
  if ((0, import_local_pkg.isPackageExists)("vue"))
    return "vue";
  if ((0, import_local_pkg.isPackageExists)("react"))
    return "react";
  if ((0, import_local_pkg.isPackageExists)("preact"))
    return "preact";
  if ((0, import_local_pkg.isPackageExists)("svelte"))
    return "svelte";
  return "none";
};
var analysisEntry = async (dirPath, targetName) => {
  const files = await import_promises2.default.readdir(dirPath);
  const indexFile = files.find((file) => {
    const { name, ext } = import_node_path2.default.parse(file);
    return name === targetName && [".js", ".jsx", ".ts", ".tsx"].includes(ext);
  });
  if (!indexFile)
    return ".js";
  return import_node_path2.default.parse(indexFile).ext;
};
var genFrameConfig = () => {
  console.time("analysis frame successfully");
  const frame = analysisFrame();
  Object.assign(localConfig, {
    frame
  });
  console.timeEnd("analysis frame successfully");
  log.info(`current frame is ${frame}
`);
};
var genEntryConfig = async () => {
  console.time("analysis entry successfully");
  const [isExistUI, isExistSrc] = await Promise.all([
    isExistsFolder("./ui"),
    isExistsFolder("./src")
  ]);
  if (!isExistUI && !isExistSrc) {
    log.err(
      "please configure the UI entry file in plugin.config.ts, such as: ./ui/index.ts"
    );
    return process.exit(-1);
  }
  const folderName = isExistUI ? "ui" : "src";
  const [uiExt, mainExt] = await Promise.all([
    analysisEntry(rootResolve(`./${folderName}`), "index"),
    analysisEntry(rootResolve("."), "main")
  ]);
  const ui = `./${folderName}/index${uiExt}`;
  const template = `./${folderName}/ui.html`;
  const main = `./main${mainExt}`;
  Object.assign(localConfig, {
    ui,
    main,
    template
  });
  console.timeEnd("analysis entry successfully");
};
var genDefaultConfig = async () => {
  genFrameConfig();
  await genEntryConfig();
};
var loadUserConfig = async () => {
  const { config } = await (0, import_c12.loadConfig)({
    name: "plugin",
    configFile: "plugin.config",
    rcFile: ".pluginrc",
    dotenv: true,
    globalRc: true
  });
  if (!config)
    return genDefaultConfig();
  if (!config.frame) {
    genFrameConfig();
  }
  if (!config.main || !config.ui) {
    await genEntryConfig();
  }
  Object.assign(localConfig, config);
};
var isBuild = false;
var overwriteEnv = (build) => {
  process.env.NODE_ENV = build ? "production" : "development";
  isBuild = build;
};
var hooks = (0, import_hookable.createHooks)();
var servicePort = 5201;

// lib/webpack/config.ts
var import_html_webpack_plugin2 = __toESM(require("html-webpack-plugin"));

// lib/webpack/plugin/html-inline-scripts.ts
var import_webpack = require("webpack");
var import_html_webpack_plugin = __toESM(require("html-webpack-plugin"));
var PLUGIN_PREFIX = "HtmlInlineScriptPlugin";
var HtmlInlineScriptPlugin = class {
  scriptMatchPattern;
  htmlMatchPattern;
  ignoredScriptMatchPattern;
  processedScriptFiles;
  ignoredHtmlFiles;
  constructor(options = {}) {
    if (options && Array.isArray(options)) {
      console.error(
        "\x1B[35m%s \x1B[31m%s %s\x1B[0m",
        "[html-inline-script-webpack-plugin]",
        "Options is now an object containing `scriptMatchPattern` and `htmlMatchPattern` in version 3.x.",
        "Please refer to documentation for more information."
      );
      throw new Error("OPTIONS_PATTERN_UNMATCHED");
    }
    const {
      scriptMatchPattern = [/.+[.]js$/],
      htmlMatchPattern = [/.+[.]html$/],
      ignoredScriptMatchPattern = []
    } = options;
    this.scriptMatchPattern = scriptMatchPattern;
    this.htmlMatchPattern = htmlMatchPattern;
    this.ignoredScriptMatchPattern = ignoredScriptMatchPattern;
    this.processedScriptFiles = [];
    this.ignoredHtmlFiles = [];
  }
  isFileNeedsToBeInlined(assetName) {
    return this.scriptMatchPattern.some((test) => assetName.match(test));
  }
  isIgnoreInjectScript(src) {
    return this.ignoredScriptMatchPattern.some((test) => src.match(test));
  }
  shouldProcessHtml(templateName) {
    return this.htmlMatchPattern.some((test) => templateName.match(test));
  }
  processScriptTag(publicPath, assets, tag) {
    if (tag.tagName !== "script" || !tag.attributes?.src) {
      return tag;
    }
    const scriptName = decodeURIComponent(tag.attributes.src.replace(publicPath, ""));
    if (!this.isFileNeedsToBeInlined(scriptName)) {
      return tag;
    }
    const asset = assets[scriptName];
    if (!asset) {
      return tag;
    }
    const { src, ...attributesWithoutSrc } = tag.attributes;
    this.processedScriptFiles.push(scriptName);
    return {
      tagName: "script",
      innerHTML: asset.source().replace(/(<)(\/script>)/g, "\\x3C$2"),
      voidTag: false,
      attributes: attributesWithoutSrc,
      meta: { plugin: "html-inline-script-webpack-plugin" }
    };
  }
  apply(compiler2) {
    let publicPath = compiler2.options?.output?.publicPath || "";
    if (publicPath && !publicPath.endsWith("/")) {
      publicPath += "/";
    }
    compiler2.hooks.compilation.tap(`${PLUGIN_PREFIX}_compilation`, (compilation) => {
      const hooks2 = import_html_webpack_plugin.default.getHooks(compilation);
      hooks2.alterAssetTags.tap(`${PLUGIN_PREFIX}_alterAssetTags`, (data) => {
        const htmlFileName = data.plugin.options?.filename;
        if (htmlFileName && !this.shouldProcessHtml(htmlFileName)) {
          this.ignoredHtmlFiles.push(htmlFileName);
          return data;
        }
        data.assetTags.scripts = data.assetTags.scripts.filter((tag) => {
          return !this.isIgnoreInjectScript(tag.attributes.src);
        }).map(
          (tag) => this.processScriptTag(publicPath, compilation.assets, tag)
        );
        return data;
      });
      compilation.hooks.processAssets.tap({
        name: `${PLUGIN_PREFIX}_PROCESS_ASSETS_STAGE_SUMMARIZE`,
        stage: import_webpack.Compilation.PROCESS_ASSETS_STAGE_SUMMARIZE
      }, (assets) => {
        if (this.ignoredHtmlFiles.length === 0) {
          this.processedScriptFiles.forEach((assetName) => {
            delete assets[assetName];
          });
        }
      });
    });
  }
};
var html_inline_scripts_default = HtmlInlineScriptPlugin;

// lib/webpack/frame/vue.ts
var mergeVueConfig = (config) => {
  config.module.rule("vue").test(/\.vue$/).use("vue-loader").loader(require.resolve("vue-loader"));
  config.plugin("vue-loader").use(require("vue-loader").VueLoaderPlugin);
  config.module.rules.get("css").uses.delete("style-loader");
  config.module.rule("css").test(/\.css$/i).use("vue-style-loader").loader(require.resolve("vue-style-loader")).before("css-loader").end();
};

// lib/webpack/frame/svelte.ts
var mergeSvelteConfig = (config) => {
  config.resolve.extensions.add(".svelte").end().mainFields.clear().add("svelte").add("browser").add("module").add("main").end();
  config.module.rule("svelte").test(/\.svelte$/).use("svelte-loader").loader(require.resolve("svelte-loader")).options(hasTs() ? {
    preprocess: require("svelte-preprocess")()
  } : {}).end();
};

// lib/webpack/frame/preact.ts
var mergePreactConfig = () => {
  return {
    jsc: {
      parser: {
        syntax: "typescript",
        jsx: true,
        tsx: true,
        target: "es2015"
      },
      transform: {
        legacyDecorator: true,
        decoratorMetadata: true,
        react: {
          pragma: "h",
          throwIfNamespace: true,
          development: false,
          useBuiltins: false
        }
      }
    }
  };
};

// lib/webpack/frame/react.ts
var mergeReactConfig = () => {
  return {
    jsc: {
      parser: {
        syntax: "typescript",
        jsx: true,
        tsx: true,
        target: "es2015"
      },
      transform: {
        legacyDecorator: true,
        decoratorMetadata: true,
        react: {
          pragma: "React.createElement",
          pragmaFrag: "React.Fragment",
          throwIfNamespace: true,
          development: false,
          useBuiltins: false
        }
      }
    }
  };
};

// lib/webpack/config.ts
var WebpackBaseConfig = class {
  config = new import_webpack_chain.default();
  constructor() {
    const { config } = this;
    config.mode(isBuild ? "production" : "development").devtool(isBuild ? false : "inline-source-map");
    config.optimization.usedExports(false).end();
    config.output.path(import_path.default.resolve(root, "./dist")).clear().end();
    config.resolve.extensions.merge([".ts", ".tsx", ".mjs", ".js", ".jsx", ".vue", ".json", ".wasm"]).end().alias.set("@", import_path.default.resolve(root, "./src"));
    this.injectRules();
    isBuild && this.terser();
  }
  get configuration() {
    return this.config.toConfig();
  }
  injectRules() {
    const { config } = this;
    const { frame } = localConfig;
    config.module.rule("js").test(/\.(j|t)sx?$/).exclude.add(/node_modules/).end().use("swc").loader(require.resolve("swc-loader")).options(
      Object.assign(
        {
          minify: isBuild
        },
        frame && frame === "preact" ? mergePreactConfig() : mergeReactConfig()
      )
    );
    config.module.rule("images").test(/\.(png|jpe?g|gif|webp|avif)(\?.*)?$/).use("url-loader").loader(require.resolve("url-loader")).options({
      limit: isBuild ? 1e8 : 1e8,
      encoding: "base64"
    }).end();
    config.module.rule("font").test(/\.(eot|ttf|woff|woff2)(\?.*)?$/).use("url-loader").loader(require.resolve("url-loader")).options({
      limit: isBuild ? 1e8 : 1e8,
      encoding: "base64"
    }).end();
    config.module.rule("svg").test(/\.svg(\?.*)?$/).use("svg-url-loader").loader(require.resolve("svg-url-loader")).options({
      encoding: isBuild ? "base64" : "none"
    }).end();
  }
  terser() {
    const TerserPlugin = require("terser-webpack-plugin");
    this.config.optimization.minimizer("terser").use(TerserPlugin, [
      {
        minify: TerserPlugin.swcMinify,
        terserOptions: {
          compress: {
            unused: true
          },
          mangle: true
        },
        parallel: true
      }
    ]).end();
  }
};
var WebpackMainConfig = class extends WebpackBaseConfig {
  constructor() {
    super();
    const { config } = this;
    config.entry("main").add(localConfig.main || "").end();
    config.plugin("progress").use(import_webpackbar.default, [
      {
        name: "Main",
        color: "#555cfd"
      }
    ]);
    config.performance.hints(false).maxAssetSize(1e8).maxEntrypointSize(1e8).end();
  }
};
var WebpackHostConfig = class extends WebpackBaseConfig {
  constructor() {
    super();
    const { config } = this;
    config.entry("host").add(localConfig.host || "").end();
    config.plugin("progress").use(import_webpackbar.default, [
      {
        name: "Host",
        color: "#F833DD"
      }
    ]);
    config.performance.hints(false).maxAssetSize(1e8).maxEntrypointSize(1e8).end();
  }
};
var WebpackUIConfig = class extends WebpackBaseConfig {
  constructor() {
    super();
    const { ui, chainWebpack, frame } = localConfig;
    if (!ui)
      return;
    const { config } = this;
    config.entry("ui").add(ui).end();
    this.injectCssRule();
    this.injectPlugins();
    switch (frame) {
      case "vue":
        mergeVueConfig(config);
        break;
      case "svelte":
        mergeSvelteConfig(config);
        break;
      default:
        break;
    }
    isBuild && config.performance.hints(false).maxAssetSize(1e8).maxEntrypointSize(1e8).end();
    chainWebpack && chainWebpack(config);
  }
  injectPlugins() {
    this.config.plugin("progress").use(import_webpackbar.default, [
      {
        name: "UI",
        color: "green"
      }
    ]).end().plugin("html").use(import_html_webpack_plugin2.default, [
      {
        template: localConfig.template,
        filename: "ui.html",
        inject: "body",
        cache: false
      }
    ]).end();
    isBuild && this.config.plugin("inline-script").use(html_inline_scripts_default, [
      {
        scriptMatchPattern: [/ui.js$/],
        htmlMatchPattern: [/ui.html$/]
        // ignoredScriptMatchPattern: [/main.js$/]
      }
    ]).end();
  }
  loadLoader(ruleName, reg, loader) {
    const { module: module2 } = this.config;
    module2.rule(ruleName).test(reg).use("style-loader").loader(require.resolve("style-loader")).end().use("css-loader").loader(require.resolve("css-loader")).options({
      esModule: false
    }).end();
    if (loader) {
      let resolvedLoader;
      try {
        resolvedLoader = require.resolve(loader);
      } catch (error) {
        resolvedLoader = loader;
      }
      module2.rule(ruleName).test(reg).use(loader).loader(resolvedLoader).end();
    }
    module2.rule(ruleName).test(reg).use("esbuild-loader").loader(require.resolve("esbuild-loader")).options({
      loader: "css",
      minify: true,
      implementation: require("esbuild")
    });
  }
  injectCssRule() {
    this.loadLoader("css", /\.css$/i);
    this.loadLoader("less", /\.less$/i, "less-loader");
    this.loadLoader("scss", /\.scss$/i, "sass-loader");
    this.loadLoader("sass", /\.sass$/i, "sass-loader");
    this.loadLoader("stylus", /\.stylus$/i, "stylus-loader");
  }
};

// lib/webpack/compiler/compiler.ts
var import_webpack2 = __toESM(require("webpack"));
var import_memory_fs = __toESM(require("memory-fs"));
var import_path2 = __toESM(require("path"));
var import_fs = __toESM(require("fs"));
var import_chalk3 = __toESM(require("chalk"));

// lib/webpack/compiler/stats.ts
var import_chalk2 = __toESM(require("chalk"));
var printStats = (err, stats, type) => {
  if (err) {
    console.log(import_chalk2.default.red("Server critical error"));
    throw err;
  }
  if (!stats)
    return false;
  const jsonStats = stats.toJson();
  if (stats.hasErrors()) {
    jsonStats.errors?.forEach((err2) => {
      const { stack, details, message } = err2;
      const error = stack || details || message;
      console.error(`${import_chalk2.default.red(`[${type} Error]: `)}${error}`);
      console.error(`${import_chalk2.default.red(`[${type} Error]: `)}${details}`);
      console.error(`${import_chalk2.default.red(`[${type} Error]: `)}${message}`);
    });
  }
  if (stats.hasWarnings()) {
    jsonStats.warnings?.forEach((err2) => {
      const { stack, details, message } = err2;
      const warn = stack || details || message;
      console.warn(`${import_chalk2.default.yellow(`[${type} Warning]: `)}${warn}`);
    });
  }
  if (stats.hasErrors())
    return false;
  return true;
};

// lib/webpack/compiler/compiler.ts
var readMFSFile = (fs5, p, file) => {
  try {
    return fs5.readFileSync(import_path2.default.join(p, file), "utf-8");
  } catch (e) {
    console.log("read dist fail", e);
    return "";
  }
};
var watchManifest = () => watchFile("./manifest.json", () => {
  log.info("manifest.json");
  let str = "";
  try {
    str = import_fs.default.readFileSync(import_path2.default.resolve(root, "./manifest.json"), {
      encoding: "utf8"
    });
  } catch (e) {
    str = "";
  }
  hooks.callHook("update", "manifest", str);
});
var watchMain = () => {
  if (!localConfig.main)
    return;
  return watchFile(localConfig.main, (p) => {
    log.info(p);
    const mainCode = import_fs.default.readFileSync(
      import_path2.default.resolve(root, localConfig.main || ""),
      "utf8"
    );
    hooks.callHook("update", "main", mainCode);
  });
};
var watchHost = () => {
  if (!localConfig.host)
    return;
  return watchFile(localConfig.host, (p) => {
    log.info(p);
    const hostCode = import_fs.default.readFileSync(
      import_path2.default.resolve(root, localConfig.host || ""),
      "utf8"
    );
    hooks.callHook("update", "host", hostCode);
  });
};
var compilerMain = (configuration) => {
  const build = () => {
    const compiler2 = (0, import_webpack2.default)(configuration);
    compiler2.run((err, stats) => {
      printStats(err, stats, "Main");
      compiler2.close(() => {
        console.log(import_chalk3.default.green("Main build finished !!!"));
      });
    });
  };
  const dev = () => {
    const compiler2 = (0, import_webpack2.default)(configuration);
    const serverMfs = new import_memory_fs.default();
    compiler2.outputFileSystem = serverMfs;
    compiler2.watch({}, () => {
      const mainCode = readMFSFile(serverMfs, compiler2.outputPath, "main.js");
      hooks.callHook("update", "main", mainCode);
    });
  };
  return isBuild ? build() : dev();
};
var compilerHost = (configuration) => {
  const build = () => {
    const compiler2 = (0, import_webpack2.default)(configuration);
    compiler2.run((err, stats) => {
      printStats(err, stats, "Host");
      compiler2.close(() => {
        console.log(import_chalk3.default.green("Host build finished !!!"));
      });
    });
  };
  const dev = () => {
    const compiler2 = (0, import_webpack2.default)(configuration);
    const serverMfs = new import_memory_fs.default();
    compiler2.outputFileSystem = serverMfs;
    compiler2.watch({}, () => {
      const mainCode = readMFSFile(serverMfs, compiler2.outputPath, "host.js");
      hooks.callHook("update", "host", mainCode);
    });
  };
  return isBuild ? build() : dev();
};
var uiHtml = `<html>
<head>
    <title>pixso plugin debug</title>
    <style>
      body {
        margin: 0;
      }
      iframe {
        height: 100%;
        width: 100%;
        border: none;
      }
    </style>
    <script>
    window.addEventListener("message", (event) => {
      const iframeGlobal = document.getElementById('devIframe').contentWindow;
      if(event.source === iframeGlobal) {
        if(event.data?.pluginDrop && typeof event.data.pluginDrop.relativeToPluginCoordinates !== 'boolean'){
          return parent.postMessage({ pluginDrop: Object.assign(event.data.pluginDrop, { relativeToPluginCoordinates: true })}, "*");
        }
        return parent.postMessage(event.data);
      }
      return iframeGlobal.postMessage(event.data, "*");
    })
    </script>
</head>
<body><iframe id="devIframe" src="http://localhost:5201"></iframe></body>
</html>`;
var compilerUI = (configuration) => {
  const compiler2 = (0, import_webpack2.default)(configuration);
  if (isBuild)
    return compiler2.run((err, stats) => {
      printStats(err, stats, "UI");
      compiler2.close(() => {
        console.log(import_chalk3.default.green("UI build finished !!!"));
      });
    });
  compiler2.hooks.done.tap("pixso-plugin-cli", async (stats) => {
    if (!printStats(null, stats, "UI"))
      return;
    hooks.callHook("update", "ui", uiHtml);
  });
  compiler2.hooks.failed.tap("pixso-plugin-cli", (error) => {
    console.log(import_chalk3.default.red("Client compilation failed"));
    console.error(error);
  });
  return compiler2;
};

// lib/webpack/index.ts
var import_rimraf = __toESM(require("rimraf"));

// lib/webpack/dev-server.ts
var import_webpack3 = __toESM(require("webpack"));
var import_express = __toESM(require("express"));
var import_webpack_dev_middleware = __toESM(require("webpack-dev-middleware"));
var import_webpack_hot_middleware = __toESM(require("webpack-hot-middleware"));
var import_http_proxy_middleware = require("http-proxy-middleware");

// lib/webpack/middleware.ts
var import_express_ws = __toESM(require("express-ws"));
var pool = [];
var messages = /* @__PURE__ */ new Map();
var remove = (ws) => {
  const idx = pool.indexOf(ws);
  if (idx === -1)
    return;
  pool.splice(idx, 1);
};
var subUpdate = () => {
  return hooks.hook("update", (name, content) => {
    const msg = messages.get(name);
    if (msg && msg === content)
      return;
    messages.set(name, content);
    pool.forEach((socket) => socket.send(JSON.stringify({
      name,
      content
    })));
  });
};
var pluginScoket = (app) => {
  const eWs = (0, import_express_ws.default)(app);
  subUpdate();
  eWs.app.ws("/plugin", (ws) => {
    pool.push(ws);
    messages.forEach((content, name) => {
      ws.send(JSON.stringify({ name, content }));
    });
    ws.on("message", (msg) => {
      console.log(msg);
    });
    ws.on("error", (err) => {
      console.log("scoket error", err);
      remove(ws);
    });
    ws.on("close", () => {
      remove(ws);
    });
  });
  return eWs.app;
};

// lib/webpack/dev-server.ts
var setupDevServer = (config) => {
  const app = (0, import_express.default)();
  config.plugins?.push(new import_webpack3.default.HotModuleReplacementPlugin());
  config.entry.ui = [
    "webpack-hot-middleware/client?reload=true",
    ...config.entry.ui
  ];
  const compiler2 = compilerUI(config);
  if (!compiler2)
    return;
  app.use((0, import_webpack_dev_middleware.default)(compiler2, {
    publicPath: config.output?.publicPath,
    stats: "none",
    index: "ui.html"
  }));
  app.use((0, import_webpack_hot_middleware.default)(compiler2, {
    heartbeat: 5e3
  }));
  if (config?.devServer?.proxy) {
    const { proxy } = config.devServer;
    Object.keys(proxy).forEach((context) => {
      app.use(context, (0, import_http_proxy_middleware.createProxyMiddleware)(proxy[context]));
    });
  }
  const eWsApp = pluginScoket(app);
  eWsApp.listen(servicePort);
};

// lib/webpack/index.ts
var import_webpack_merge = require("webpack-merge");
var compiler = () => {
  const uiConfig = new WebpackUIConfig();
  const mainConfig = new WebpackMainConfig();
  const { ui, mainBuild, host, hostBuild, configureWebpack } = localConfig;
  const { configuration: mainConfiguration } = mainConfig;
  if (mainConfiguration.output && mainConfiguration.output.path) {
    import_rimraf.default.sync(mainConfiguration.output.path);
  }
  mainBuild ? compilerMain(mainConfiguration) : watchMain();
  if (host) {
    const hostConfig = new WebpackHostConfig();
    const { configuration: hostConfiguration } = hostConfig;
    if (hostConfiguration.output && hostConfiguration.output.path) {
      import_rimraf.default.sync(hostConfiguration.output.path);
    }
    hostBuild ? compilerHost(hostConfiguration) : watchHost();
  }
  if (ui) {
    let { configuration: uiConfiguration } = uiConfig;
    if (typeof configureWebpack === "function") {
      configureWebpack(uiConfiguration);
    } else {
      uiConfiguration = (0, import_webpack_merge.merge)(uiConfiguration, configureWebpack || {});
    }
    isBuild ? compilerUI(uiConfiguration) : setupDevServer(uiConfiguration);
  }
  !isBuild && watchManifest();
};

// lib/pkg.ts
var import_node_fs = __toESM(require("fs"));
var import_archiver = __toESM(require("archiver"));
var import_ora = __toESM(require("ora"));
var manifestPath = "./manifest.json";
var genPkg = () => {
  const spinner = (0, import_ora.default)("pkging...").start();
  let manifest;
  try {
    manifest = require(rootResolve(manifestPath));
  } catch (e) {
    spinner.fail();
    console.log("the manifest.json file was not found in the current directory", e);
    process.exit(-1);
  }
  const { name } = manifest;
  const output = import_node_fs.default.createWriteStream(rootResolve(`./${name}.zip`));
  const archive = (0, import_archiver.default)("zip", {
    zlib: { level: 9 }
  });
  output.on("close", function() {
    spinner.succeed();
    console.log(archive.pointer() + " total bytes");
  });
  output.on("end", function() {
    spinner.fail();
  });
  archive.pipe(output);
  archive.directory("dist/", "dist");
  archive.append(JSON.stringify(manifest), { name: "manifest.json" });
  archive.finalize();
};

// lib/cli.ts
var cli = (0, import_cac.cac)("plugin-cli");
cli.command("[root]").alias("dev").action(async () => {
  await loadUserConfig();
  compiler();
});
cli.command("build [root]").action(async () => {
  overwriteEnv(true);
  await loadUserConfig();
  compiler();
});
cli.command("pkg [root]").action(
  genPkg
);
cli.command("upgrade [plugin-name]").action(async (packageName) => {
  console.log("\u529F\u80FD\u5F00\u53D1\u4E2D\uFF0C\u656C\u8BF7\u671F\u5F85~", packageName);
});
cli.help();
cli.version(require_package().version);
cli.parse();
